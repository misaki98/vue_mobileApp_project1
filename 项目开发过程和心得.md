# 这是一个项目的介绍

1. Header区域使用了Mint-UI中的header组件
2. 底部Tabbar区域使用了MUI的Tabbar.html组件
      导入了扩展图标的样式css和字体库ttf
      并且要添加对应的类的样式
3. 中间router-view放置路由匹配到的组件

## 改造 tabbar 为 router-link

## 设置路由高亮

## 创建对应的组件，并放到统一的文件夹中

## 制作首页轮播图布局

## 加载轮播图数据
1. 获取数据，使用vue-resource 主要为Ajax方法
2. 使用vue-resource 的this.$http.get 获取数据
3. 将获取到的数据保存到data身上
4. 使用v-for将数据渲染到view上

## 改造九宫格区域样式

## 改造 新闻资讯 路由链接和页面制作
1. 绘制界面（使用MUI绘制）
2. 使用vue-resource获取数据
    a. 使用Easy Mock创建假数据并建立对应的接口，设置根路径之后可以直接访问
    b. 将生成的假数据下载到本地，是用Node.js建立服务器并监听，在本地访问localhost，并配置允许跨域请求
3. 渲染数据

## 实现 新闻资讯列表 点击跳转到详情
1. 把列表的每一项改造为router-link，并且在跳转时提供唯一的ID标识符
2. 创建新闻详情的组件页面 NewsInfo.vue
3. 在路由模块中配置对于的组件页面和将其与其他组件对应起来

## 实现 新闻详情 的页面布局和数据渲染

## 单独封装一个评论区组件
1. 先创建一个组件模板
2. 在需要使用comment组件的页面中，手动导入comment组件
    import comment from './comment.vue'
3. 在父组件中components属性，将导入的组件进行注册为子组件
4. 将注册子组件定义的名称，引用其标签即可使用子组件

## 评论区数据由后台获取，并渲染到页面中

## 实现点击加载更多评论的功能
1. 给按钮绑定点击事件，在事件中请求下一页数据
2. 点击加载更多，让pageIndex++，调用方法获取数据，然后将数据拼接到数组中

## 实现发表评论的功能
1. 将文本框做双向数据绑定
2. 为发表按钮绑定一个事件
3. 校验评论内容的合法性（是否为空），使用Toast来提示
4. 使用 vue-resource 发送请求，把评论提交给服务器
5. 当发表评论后，直接把评论使用unshift方法插入评论列表（使用getComments可能会导致数据插入位置出现问题）

## 改造图片分享按钮为路由链接 并显示对应页面

## 绘制图片列表组件页面结构并美化页面
### 制作顶部的滑动条
    a. 需要借助MUI中的tab-top-webview-mian
    b. 需要把 mui-fullscreen 这个类去除
    c. 滚动条无法正常触发滑动，需要初始化控件
       导入mui.js
       调用官方提供的方式初始化
       ```
       mui('.mui-scroll-wrapper').scroll({
       	deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006
       });
       ```、
    d. 在初始化时遇到严格模式冲突问题，修改webpack中的配置方法，取消严格模式
    e. 取消严格模式后，滑动条出现无法正常工作情况，分析后得出 必须要等到DOM元素加载完毕后才能进行初始化
    所以将初始化代码放入mounted生命周期钩子函数后，问题得到解决
    f. 取消严格模型后，路由出现无法使用的问题，分析后得出是js中的类名发生了冲突，修改类名，自己重写样式后问题解决
    g. 获取数据。渲染列表
### 制作中间的图片列表
    a. 使用懒加载技术制作加载图片列表，使用Mint-ui现成的组件即可实现
    b. 渲染图片列表数据和美化样式

### 点击实现跳转到图片详情页面
    a. 在改造 li 成 router-link 的时候，需要使用tag属性指定要渲染成那种标签
    b. 获取详情页面的数据，并美化样式

### 实现图片详情页中的缩略图
    a. 使用vue2-preview缩略图插件
    b. 获取到所有图片列表，渲染到页面上
    c. img标签上的class属性不能去除
    d. 每个图片对象上都有 w 和 h 属性，需要使用forEach为每个图片加上这些属性

## 绘制 商品列表 页面基本结构并美化样式

## 尝试在手机上进行项目的预览和测试
   1. 要保证手机可以正常运行
   2. 保证手机和电脑处于同一个WIFI环境中，也就是手机可以访问到电脑的IP
   3. 打开 项目中的package.json 文件，在dev脚本中，添加 --host 指令，将电脑的WIFI IP地址设置为 --host 的指令值
     在cmd中运行 'ipconfig' 查看无线网的IP地址

## 加载商品列表，并将其渲染为链接
   1. 在网页中，有两种跳转方式
      a. 使用 a 标签的方式，称为标签跳转（包括router-link）
      b. 使用 window.location.href 的形式，称为编程式导航（为标签绑定事件）
   2. 区分 this.$route 和 this.$router 两个对象
      a. 其中，this.$route 是【路由参数对象】，所有路由中的参数，params, query 都属于它
      b. this.$router  是一个【路由导航对象】，用它可以方便使用 JS 代码来实现路由的前进和后退等跳转事件

## 绘制商品详情页面
   ### 绘制顶部轮播图
      a. 将首页轮播图抽离为一个组件
      b. 分别将组件挂载到不同的页面上
      c. 商品详情页中的轮播图出现比例不对称现象，经分析后得知，轮播图图片如果也使用100%宽高比，页面不好看，应使用宽高比自适应
      d. 但宽高比自适应会导致首页轮播图出现留白，故将是否使用宽高比自适应封装为一个属性，由组件调用者自行决定使用哪种样式
   2. 中间商品购买数量部分需要使用numbox组件，该组件需要初始化
   3. 绘制底部商品参数部分
   4. 商品图文介绍页面和评论页面的渲染，使用组件
   5. 绘制小球的动画
      a. 配置动画效果
      b. 动画在不同终端中出现不准确的现象，分析后得出是动画配置中将位移距离写死了，分辨率变化时就会出现问题
      c. 故不能把位移的横纵坐标写死，而是应该根据不同情况动态计算坐标值
      d. 计算坐标使用屏幕 徽标 坐标减去 小球初始位置 的坐标来得到相对位置（纵轴减去纵轴，横轴减去横轴）
      e. 使用 domObject.getBoundingClientRect() 方法获取位置 该方法返回一个矩形对象，包含四个属性{left,top,right,bottom}
      f. 当涉及到的业务逻辑和数据没有关系时，极端情况下可以操作DOM元素来进行一些业务逻辑的编写
   ### 实现加入购物车之后，获取到选择的数量并更新到购物车上
      a. 经过分析后发现 按钮属于 goodsinfo 组件页面，数字属于 number-box 组件
      b. 由于涉及到父子组件嵌套，所以无法直接在goodsinfo页面中获取到商品数量的值
      c. 涉及到了子组件向父组件传值，使用使用调用机制
      d. 时间调用的本质：父组件向子组件传递方法，子组件调用这个方法，同时把数据作为参数传给这个方法，在子组件中通过监听change
      事件来调用这个方法传值
   ### 使用父组件向子组件传值来获取商品数量的最大值
      a. 但是由于父组件是通过异步操作来获取最大值，所以子组件渲染完成时max值可能为undefined
      b. 此时可以使用watch属性来监听父组件传过来的max值，当最后一次触发watch时肯定是合法的
      c. 最后使用JS api来控制max
   ### 获取到选择的数量并更新到购物车上
      1. (使用Vuex状态管理控制工具)[https://vuex.vuejs.org/zh/]
      2. 分析：
        2.1 如果购物车中已经有这个对应的商品了，则只需更新数量即可
        2.2 如果没有，则直接把商品数据push到car中即可
      3. 将购物车中所有选中的count值相加即为购物车上小红点的值，使用getters实现
   ### 不仅仅在购物车上，购物车中的数据必须在本地也有一份保存备份，以免用户刷新网站或者二次加载时购物车被清空

   ## 绘制购物车页面
   1. 从store中获取已经加入购物车的所有商品数据，然后从服务器获取商品的详细信息，渲染到页面上
   2. 但是商品的数量比较难以获取，分析后得出以下方法：
       2.1 可以创建一个空对象，然后循环商品的数据，把当前循环这个商品的ID作为属性名，count值作为属性值，当把所有的商品循环
       一遍就会得到一个对象{ id1：count1, id2:count2, ……} 通过对象[属性名]就可以获取到属性值
   3. 拿到数量后，需要将数量传递给子组件
